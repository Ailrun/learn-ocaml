<html>
  <head>
  <meta charset='UTF-8'>
  <title>basics-functions</title>
  </head>
<body>
  <h1>Functions</h1>
  <h2>Defining a one-argument function</h2>
  <p>In OCaml defining a function with one argument, will look like this:</p>
  <pre data-run>
    let incr n = n + 1
  </pre>
  <p>You can also use tuples:</p>
  <pre data-run>
    let plus_and_divide (x, y, z) = (x + y) / z
  </pre>
  <p>Note that even though you have <code>x</code> , <code>y</code> and
    <code>z</code> as arguments, this syntax with tuples means that you call
    the function plus_and_divide with <em>one</em> argument which is a triple
    in this case. To call a function, nothing is simpler:</p>
  <pre data-run>
    incr 42
  </pre>
  <pre data-run>
    plus_and_divide (10, 20, 2)
  </pre>
  <h2>Defining a multiple-arguments function</h2>
  <p>In C or Java, a function <code>plus</code> , will look like <code>int
    plus (int x, int y) { return x + y; }</code> . Then the call to this
    function, will be: <code>plus (1, 2);</code> In OCaml, the same function
    <code>plus</code> will be define like follow:</p>
  <pre data-run>
    let plus x y = x + y
  </pre>
  <p>To call this function, nothing is simpler:</p>
  <pre data-run>
    plus 1 2
  </pre>
  <p>Note that there is no need to bracket or comma between function's
    parameters.</p>
  <h2>Returning multiple values</h2>
  <p>You will notice that in OCaml, there is no <code>return</code>
    statement; to return a value, the whole body expression is implicitly
    returned.To return multiple values, we will use tuples. For example:</p>
  <pre data-run>
    (2, 3, 4, 5)
  </pre>
  <p>We can write functions which will return multiple values thanks to
    tuples. For example:</p>
  <pre data-run>
    let divide x y = (x / y, x mod y)
  </pre>
  <p>Then we get:</p>
  <pre data-run>
    divide 10 3
  </pre>
  <h2>Partial application</h2>
  <p>It is possible to apply a number of parameters less than what is
    required by a function. The result would be a partial application of a
    function.Let's take the <code>plus</code> example:</p>
  <pre data-run>
    let plus x y = x + y
  </pre>
  <p>Using the partial application, we could rewrite the function
    <code>incr</code> , by giving just one argument to the function
    <code>plus</code> :</p>
  <pre data-run>
    let incr = plus 1
  </pre>
  <p>In this way, <code>plus 1</code> will return a function arity 1:
    <code>val incr : int -&gt; int = &lt;fun&gt;</code> . To increment an
    integer by one, you can now use the function <code>incr</code> :</p>
  <pre data-run>
    incr 42
  </pre>
  <p>Similarly, we can define a function which double each integer passed as
    argument of the function:</p>
  <pre data-run>
    let mul x y = x * y
  </pre>
  <pre data-run>
    let double = mul 2
  </pre>
  <pre data-run>
    double 8
  </pre>
  <h2>Anonymous functions</h2>
  <p>In OCaml, we can write anonymous functions, functions defined without
    being bound to an identifier. For example:</p>
  <pre data-run>
    (fun x -&gt; x + 1) 42
  </pre>
  <p>We can bound an anonymous function to an identifier. That's way, we have
    severals ways to define functions:</p>
  <pre data-run>
    let incr = fun x -&gt; x + 1
  </pre>
  <pre data-run>
    incr 42
  </pre>
  <h2>Iterators</h2>
  <p>What is really fun is that you can now mix anonymous functions and
    iterators. Let's take an example with list. If you want to increment all
    elements of a list, you will use <code>List.map</code> :</p>
  <pre data-run>
    List.map (fun x -&gt; x + 1) [ 1; 2; 3; 4 ]
  </pre>
  <p>Here, <code>x</code> is an element of the list, <code>x +
    1</code>
    is the operation that will be done on <code>x</code> . The result will be
    a list with all its elements incremented by 1.Here is an example with
    <code>fold_left</code> . If you want to compute the sum of all elements
    of a list:</p>
  <pre data-run>
    List.fold_left
         (fun acc x -&gt; acc + x)
         0
         [ 1; 2; 3; 4 ]
  </pre>
  <p>If we have :</p>
  <pre data-run>
    let plus = fun acc x -&gt; acc + x
  </pre>
  <p>then:</p>
  <pre data-run>
    List.fold_left plus 0 [ 1; 2; 3; 4 ]
  </pre>
  <p>is equivalent to:</p>
  <pre data-run>
    plus (plus (plus (plus 0 1) 2) 3) 4
  </pre>
  <p>To finish, you may need to print values from a list:</p>
  <pre data-run>
    List.iter print_int [ 1; 2; 3; 4 ]
  </pre>
  <p>You can do the same sort of things on arrays too.</p></body>
</html>
