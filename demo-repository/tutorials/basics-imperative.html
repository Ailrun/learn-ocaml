<html>
  <head>
  <meta charset='UTF-8'>
  <title>basics-imperative</title>
  </head>
<body>
  <h1>A Taste of Imperative Programming</h1>
  <h2>Variables</h2>
  <p>As in other languages, you can associate a name to a value. To do that,
    we use the <code>let</code> syntax which associates the result of some
    computation with a name:</p>
  <pre data-run>
    let x = 6 * 7
  </pre>
  <p>We can now check the value associated with <code>x</code> in the
    toplevel:</p>
  <pre data-run>
    x
  </pre>
  <p>And we can use the name where we would like the value:</p>
  <pre data-run>
    let y = x + 1
  </pre>
  <h2>Mutable Variables</h2>
  <p>In OCaml, you cannot change the value associated with a name after its
    definition. Trying to do so will trigger a compilation error:</p>
  <pre data-run>
    x &lt;- x + 1
  </pre>
  <p>You will better understand the error message later.If you really want to
    modify the value associated with a name, you must use a trick. OCaml
    provides a function <code>ref</code> that creates a special value that
    can be modified later (a reference):</p>
  <pre data-run>
    let x = ref 42
  </pre>
  <p>You can then change the value of the reference associated with
    <code>x</code> using the <code>:=</code> operator:</p>
  <pre data-run>
    x := 100 / 4
  </pre>
  <p>You can also access the value contained in the reference using the
    operator <code>!</code> :</p>
  <pre data-run>
    let y = !x + 1
  </pre>
  <h2>Sequences and Printing</h2>
  <p>OCaml provides different functions to print basic types. For example:</p>
  <pre data-run>
    print_int 3
  </pre>
  <p>and:</p>
  <pre data-run>
    print_string "Hello"
  </pre>
  <p>Sequences of expressions are separated by <code>;</code> :</p>
  <pre data-run>
    print_string "x = ";
    print_int !x;
    print_newline ()
  </pre>
  <p>A more powerful method to print values is <code>Printf.printf</code> ,
    whose behavior is similar to <code>printf</code> in C:</p>
  <pre data-run>
    Printf.printf "x = %d. Bye %s\n" !x "John"
  </pre>
  <h2>For loops</h2>
  <p>Let's define a reference on a list:</p>
  <pre data-run>
    let xl = ref []
  </pre>
  <p>OCaml provides a simple <code>for</code> loop to iterate on integers in
    a range:</p>
  <pre data-run>
    for i = 1 to 10 do
      xl := i :: !xl;
    done;
    !xl
  </pre>
  <p>Here, for each value between 1 and 10, we have added it in this order at
    the head of the reference.Of course, if we want them in the correct
    order, we need to reverse the list:</p>
  <pre data-run>
    List.rev !xl
  </pre>
  <p>Or we can just execute the loop directly from the upper bound to the
    lower bound:</p>
  <pre data-run>
    for i = 10 downto 1 do
     xl := i :: !xl
    done;
    !xl
  </pre>
  <h2>Computing Conditions</h2>
  <p>Boolean values in OCaml can be either <code>true</code> or
    <code>false</code> . They are often created from comparing other values.
    For example:</p>
  <pre data-run>
    1 &gt; 2
  </pre>
  <p>OCaml's comparison operators can be used on values of any type, not only
    on numerical values. We can compare strings and characters too:</p>
  <pre data-run>
    "aaaaaa" &lt; "bbb"
  </pre>
  <pre data-run>
    "3" &lt;= "22"
  </pre>
  <pre data-run>
    22 &gt;= 3
  </pre>
  <p>To test equality, you can use <code>=</code> , and for inequality, there
    is <code>&lt;&gt;</code> . For example:</p>
  <pre data-run>
    1 = 1
  </pre>
  <pre data-run>
    1 &lt;&gt; 1
  </pre>
  <pre data-run>
    "1" = 1
  </pre>
  <p>Oops, OCaml does not allow you to compare values with different types,
    so we must be more careful:</p>
  <pre data-run>
    "1" = string_of_int 1
  </pre>
  <h2>If then else</h2>
  <p>Now that we know how to test conditions, we can use them to choose
    between computations. Let's define two values :</p>
  <pre data-run>
    let a = 1 and b = 2
  </pre>
  <p>We can compute the minimum of them:</p>
  <pre data-run>
    Printf.printf "min(%d,%d) = %d\n" a b
        (if a &lt; b then a else b)
  </pre>
  <p>We can of course execute sequences within branches:</p>
  <pre data-run>
    let z = if a &lt; 100 then begin
        print_string "return at least 100 !";
        print_newline ();
        100
     end else a
  </pre>
  <h2>While loops</h2>
  <p>OCaml also provides a <code>while</code> loop, to execute some code as
    long as an expression is true:</p>
  <pre data-run>
    while !x &gt; 20 do
      print_int !x; print_newline ();
      x := !x - 2
    done
  </pre>
  <h2>Congratulations</h2>
  <p>You have seen that OCaml allows you to use some imperative style of
    programming. Some functional programmers will tell you that side-effects
    are bad: they are right, in many cases, but don't listen to them too
    early !In the next lessons, you will see that by combining both
    imperative and functional programming styles!</p></body>
</html>
