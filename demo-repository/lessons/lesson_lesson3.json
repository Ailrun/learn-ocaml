{
    "learnocaml_version": "1",
    "title": "Functions",
    "steps": [
      {
        "title": "Defining a one-argument function",
        "contents": [
          {
            "html": "In OCaml defining a function with one argument, will look like this:"
          },
          {
            "code": "let incr n = n + 1"
          },
          {
            "html": "You can also use tuples:"
          },
          {
            "code": "let plus_and_divide (x, y, z) = (x + y) / z"
          },
          {
            "html": "Note that even though you have <code>x</code>, <code>y</code> and <code>z</code> as arguments, this syntax with tuples means that you call the function plus_and_divide with<strong>one</strong>argument which is a triple in this case.<br>To call a function, nothing is simpler:"
          },
          {
            "code": "incr 42"
          },
          {
            "code": "plus_and_divide (10, 20, 2)"
          }
        ]
      },
      {
        "title": "Defining a multiple-arguments function",
        "contents": [
          {
            "html": "In C or Java, a function <code>plus</code>, will look like:int plus (int x, int y) { return x + y; }Then the call to this function, will be:plus (1, 2);In OCaml, the same function <code>plus</code> will be define like follow:"
          },
          {
            "code": "let plus x y = x + y"
          },
          {
            "html": "To call this function, nothing is simpler:"
          },
          {
            "code": "plus 1 2"
          },
          {
            "html": "Note that there is no need to bracket or comma between function's parameters."
          }
        ]
      },
      {
        "title": "Returning multiple values",
        "contents": [
          {
            "html": "You will notice that in OCaml, there is no <code>return</code> statement; to return a value, the whole body expression is implicitly returned.To return multiple values, we will use tuples. For example:"
          },
          {
            "code": "(2, 3, 4, 5)"
          },
          {
            "html": "We can write functions which will return multiple values thanks to tuples. For example:"
          },
          {
            "code": "let divide x y = (x / y, x mod y)"
          },
          {
            "html": "Then we get:"
          },
          {
            "code": "divide 10 3"
          }
        ]
      },
      {
        "title": "Partial application",
        "contents": [
          {
            "html": "It is possible to apply a number of parameters less than what is required by a function. The result would be a partial application of a function.Let's take the <code>plus</code> example:"
          },
          {
            "code": "let plus x y = x + y"
          },
          {
            "html": "Using the partial application, we could rewrite the function <code>incr</code>, by giving just one argument to the function <code>plus</code>:"
          },
          {
            "code": "let incr = plus 1"
          },
          {
            "html": "In this way, <code>plus 1</code> will return a function arity 1: <code> val incr : int -&gt; int = &lt;fun&gt;</code>. To increment an integer by one, you can now use the function <code>incr</code>:"
          },
          {
            "code": "incr 42"
          },
          {
            "html": "Similarly, we can define a function which double each integer passed as argument of the function:"
          },
          {
            "code": "let mul x y = x * y"
          },
          {
            "code": "let double = mul 2"
          },
          {
            "code": "double 8"
          }
        ]
      },
      {
        "title": "Anonymous functions",
        "contents": [
          {
            "html": "In OCaml, we can write anonymous functions, functions defined without being bound to an identifier. For example:"
          },
          {
            "code": "(fun x -> x + 1) 42"
          },
          {
            "html": "We can bound an anonymous function to an identifier. That's way, we have severals ways to define functions:"
          },
          {
            "code": "let incr = fun x -> x + 1"
          },
          {
            "code": "incr 42"
          }
        ]
      },
      {
        "title": "Iterators",
        "contents": [
          {
            "html": "What is really fun is that you can now mix anonymous functions and iterators. Let's take an example with list. If you want to increment all elements of a list, you will use <code>List.map</code>:"
          },
          {
            "code": "List.map (fun x -> x + 1) [ 1; 2; 3; 4 ]"
          },
          {
            "html": "Here, <code>x</code> is an element of the list, <code>x + 1</code> is the operation that will be done on <code>x</code>. The result will be a list with all its elements incremented by 1.Here is an example with <code>fold_left</code>. If you want to compute the sum of all elements of a list:"
          },
          {
            "code": "List.fold_left\n     (fun acc x -> acc + x)\n     0\n     [ 1; 2; 3; 4 ]"
          },
          {
            "html": "If we have :"
          },
          {
            "code": "let plus = fun acc x -> acc + x"
          },
          {
            "html": "then:"
          },
          {
            "code": "List.fold_left plus 0 [ 1; 2; 3; 4 ]"
          },
          {
            "html": "is equivalent to:"
          },
          {
            "code": "plus (plus (plus (plus 0 1) 2) 3) 4"
          },
          {
            "html": "To finish, you may need to print values from a list:"
          },
          {
            "code": "List.iter print_int [ 1; 2; 3; 4 ]"
          },
          {
            "html": "You can do the same sort of things on arrays too."
          }
        ]
      }
    ]
}
